\section{Problemen}
\todo{Nog veel rewrites}
\subsection{IO Monad afsplitsen}

\todo{Onderstaande had ik (Pim) origineel geschreven voor het problemenstuk (in ontwerp). Het is over de problemen die we hadden omdat we relatief weinig haskell-kennis hadden}

\subsubsection{Kennis Haskell}
Bij het begin van het Canvas.Hs-project was de kennis over Haskell en functioneel programmeren in het algemeen beperkt tot de kennis opgedaan met het vak Functioneel programmeren. Hoewel dit een solide basis vormt is het doel van Canvas.Hs juist om een aantal concepten die niet binnen dit vak passen af te schermen van de studenten. Dit betekende dat er bij het project van deze concepten gebruik moest worden gemaakt en wij hebben ons deze eigen moeten maken. Zoals altijd bij het leren van nieuwe concepten leverde dit af en toe code die niet optimaal gebruik maakte van de beschikbare mogelijkheden.

Naarmate het project vorderde, vorderde ook onze kennis van Haskell. Hierdoor maakt de uiteindelijke versie van Canvas.Hs goed gebruik van de mogelijkheden van onder andere monadisch programmeren en het threadsysteem in Haskell.

\paragraph{Monads}
Zoals gezegd kent Haskell het concept van monads. Één van de doelen van CanvasHs is om dit concept niet te hoeven gebruiken voor grafische weergave bij het vak functioneel programmeren. Dit betekent dat ook wij, de ontwikkelaars, weinig kennis over dit concept hadden voordat aan het project begonnen werd.
Denk aan do-notatie, binds (>>=>>) en eigen monad voor de Server (state)
\todo{onvoldoende toegelicht}

\paragraph{Threads}
Denk aan gezeik met netjes de WebSockets en http-threads afsluiten en Timer-threads die nu doorlopen \todo{Dit afmaken}


\subsubsection{Records} \todo{Hier is een stukje over het recordprobleem, maar waar het heen moet weet ik niet}
Binnen Haskell is het zo dat elke sleutel van een record waarde een functie is. Als er een record gedefinieerd wordt met een sleutel ``sleutel'' bestaat er automatisch een functie \inlinecode{sleutel}. Hoewel dit op het eerste gezicht handig lijkt, betekend dit wel dat alle sleutels uniek moeten zijn. Het is zelfs zo dat sleutels globaal uniek moeten zijn, het is niet mogelijk twee records te maken (die niet in hetzelfde \inlinecode{data} element zitten) die dezelfde sleutel hebben. Hieronder staat een stukje code die dit probleem illustreerd, op de tweede statement zal de Haskell compiler een foutmelding geven.

\begin{lstlisting}[language=Haskell]
data FirstRecord = Fst { key :: String }
data SecondRecord = Snd { key :: String }
\end{lstlisting}

De meestgebruikte JSON libraries gebruiken records die daarna naar JSON vertaald worden, maar dit bleek problematisch. Omdat er zowel in het input als in het output record een veld met de naam ID was, moesten er handmatig toJSON instanties geschreven worden waar interne veldnamen omgezet werden in externe veldnamen. Deze wijziging leverde heel veel code op, daarnaast was er nog een probleem dat de JSON library (Aeson) geen lege (\inlinecode{ field = Nothing }) velden weggooide.  Uiteindelijk is er een oplossing gevonden in de vorm van Template Haskell. De Template Haskell functies voor Aeson bieden de mogelijkheid om \inlinecode{Nothing}'s te verwijderen, en daarnaast is het mogelijk om de veldnamen van de records aan te passen. Binnen de code zijn dus alle veldnamen van records voorzien van een prefix (shape, event, etc.) die er door Template Haskell weer afgehaald wordt.


