\section{Problemen}
\todo{Nog veel rewrites}
\subsection{IO Monad afsplitsen}

\todo{Onderstaande had ik (Pim) origineel geschreven voor het problemenstuk (in ontwerp). Het is over de problemen die we hadden omdat we relatief weinig haskell-kennis hadden}

\subsubsection{Kennis Haskell}
Bij het begin van het Canvas.Hs-project was de kennis over Haskell en functioneel programmeren in het algemeen beperkt tot de kennis opgedaan met het vak Functioneel programmeren. Hoewel dit een solide basis vormt is het doel van Canvas.Hs juist om een aantal concepten die niet binnen dit vak passen af te schermen van de studenten. Dit betekende dat er bij het project van deze concepten gebruik moest worden gemaakt en wij hebben ons deze eigen moeten maken. Zoals altijd bij het leren van nieuwe concepten leverde dit af en toe code die niet optimaal gebruik maakte van de beschikbare mogelijkheden.

Naarmate het project vorderde, vorderde ook onze kennis van Haskell. Hierdoor maakt de uiteindelijke versie van Canvas.Hs goed gebruik van de mogelijkheden van onder andere monadisch programmeren en het threadsysteem in Haskell.

\paragraph{Monads}
Zoals gezegd kent Haskell het concept van monads. Één van de doelen van CanvasHs is om dit concept niet te hoeven gebruiken voor grafische weergave bij het vak functioneel programmeren. Dit betekent dat ook wij, de ontwikkelaars, weinig kennis over dit concept hadden voordat aan het project begonnen werd.
Denk aan do-notatie, binds (>>=>>) en eigen monad voor de Server (state)
\todo{onvoldoende toegelicht}

\paragraph{Threads}
Denk aan gezeik met netjes de WebSockets en http-threads afsluiten en Timer-threads die nu doorlopen \todo{Dit afmaken}


\subsubsection{Records} \todo{Hier is een stukje over het recordprobleem, maar waar het heen moet weet ik niet}
Binnen Haskell is het zo dat elke sleutel van een record waarde een functie is. Als er een record gedefinieerd wordt met een sleutel ``sleutel'' bestaat er automatisch een functie \inlinecode{sleutel}. Hoewel dit op het eerste gezicht handig lijkt, betekend dit wel dat alle sleutels uniek moeten zijn. Het is zelfs zo dat sleutels globaal uniek moeten zijn, het is niet mogelijk twee records te maken (die niet in hetzelfde \inlinecode{data} element zitten) die dezelfde sleutel hebben.

De meestgebruikte JSON libraries gebruiken records die daarna naar JSON vertaald worden, maar dit bleek problematisch. Omdat er meerdere records waren met dezelfde veldnamen, moesten er handmatig toJSON instanties geschreven worden waar interne veldnamen omgezet werden in externe veldnamen. Uiteindelijk is er een oplossing gevonden in de vorm van Template Haskell. Door toJSON kan aangegeven worden dat veldnamen aangepast moeten worden. Alle records worden daardoor voorzien van een prefix die er door Template Haskell afgehaald wordt.


