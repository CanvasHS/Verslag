\subsection{Grafische bibliotheek} \label{subsec:grafische_bibliotheek}

Binnen de library zijn een aantal ontwerpkeuzes moeten maken. Ten eerste moeten kiezen hoe de gebruiker tekent, maar ook hoe events op elementen geplaatst worden en hoe de gebruiker laten omgaan met IO.

\subsubsection{Grafisch}
De meest belangrijke keuze die gemaakt is, is hoe er getekend wordt. Voorheen werd er binnen het vak Functioneel Programmeren gebruik gemaakt van Gloss. Binnen Gloss wordt alles relatief getekend en dan getransleerd, op een manier gelijkend aan OpenGl. Deze manier van tekenen is gestructureerd, maar zeker niet eenvoudig. Het tekenen van elementen op arbitraire plaatsen van het scherm heeft zowel een shape als een translatie nodig.

De tegenhanger van deze methode is het absoluut tekenen van alle elementen. Voor het tekenen van kleine grafische interfaces is dit erg eenvoudig, teken gewoon een paar vierkantjes op arbitraire locaties op het canvas. Het nadeel van deze methode is dat als er meerdere vormen verplaatst moeten worden, dit stuk voor stuk moet gebeuren. Daarnaast is het invullen van een vorm een attribuut van de vorm, en daartoe is het niet mogelijk om meerdere elementen tegelijk van kleur te voorzien. Dat probleem zou opgelost kunnen worden door functies binnen de module te defini\"eren die op een lijst van shape een translatie kan toepassen.

Er is ook het tekenmodel van de Javascript library, Kinetic. Deze tekent alles absoluut, maar ondersteunt lagen die afzonderlijk geschaald kunnen worden. Er is besloten zo min mogelijk protocollen te willen, daartoe is er eerst gekeken naar het doortrekken van het Kinetic model naar het grafisch model van de Canvas.Hs module, vooral zodat er maar een echt datamodel zou zijn, en omdat de client dan triviaal in elkaar gezet kon worden.

Uiteindelijk is het een compromis geworden tussen het datamodel van Kinetic en van Gloss. De gebruiker tekent het overgrote gedeelte van de elementen absoluut, maar kan elementen groeperen in een \inlinecode{Container}. Binnen een \inlinecode{Container} is wederom een absoluut co"ordinatenstelsel, waar de gebruiker dan shapes in kan tekenen. Verder zijn er translaties mogelijk op shapes, zo kan de gebruiker een vorm roteren, en deze translaties werken ook op Containers. Wil de gebruiker bijvoorbeeld een knop met een pijltje draaien, dan kan deze in een container geplaatst worden, en in zijn geheel geroteerd worden.

Dit datamodel combineert dus de goede kanten van Kinetic (het snel absoluut kunnen tekenen van vormen) met de voordelen van Gloss (het makkelijk kunnen verplaatsen, kleuren, roteren etc. van meerdere shapes).
\todo{Afkortingen verwijderen?}

Om deze keuze te illustreren volgt een ``Mickey Mouse'' vorm die gedraaid en gekleurd is. Hier is goed te zien hoe binnen de Container een absoluut co\"ordinatenstelsel heerst, terwijl erbuiten relatieve bewerkingen uitgevoerd worden.

\begin{lstlisting}[style=densecode, language=Haskell]
Fill black $ Translate 100 100 $ Rotate 90 $ Container 200 200 [
            Circle (70, 130) 20,
            Circle (100, 100) 50,
            Circle (130, 130) 20
        ]
\end{lstlisting}

\subsection{Protocol}
Uiteindelijk is ervoor gekozen om het protocol gelijkend aan Kinetic op te bouwen, zo zijn de meeste JSON berichten die gestuurd worden door de Canvas.Hs module een op een te teken op het canvas. Wel zijn er hier en daar kleine verschillen, JSON-keys die net anders zijn, of er zijn andere keys gebruikt om hetzelfde te modelleren (Een goed voorbeeld hiervan is de kleuren, kleuren worden opgestuurd als object met r, g , b en a waarden, maar Kinetic verwacht een string met een kleur zoals hij geaccepteerd wordt door een webbrowser. De manier hoe Kinetic omgaat met een kleur is een implementatiedetail dat niet thuis hoort in een protocol).
\todo{Niet zo veel tussen haakjes zetten}

\subsubsection{ID's}
Er is besloten events te ondersteunen, de bestaande Functioneel Programmeren module geeft de gebruiker een (x,y) co"ordinaat maar geen direct event. De library zoekt zelf uit op welk element er geklikt is en vuurt bijvoorbeeld een MouseClick met een identifier. Hiertoe moest er besloten worden hoe identifiers uitgegeven worden, er is gekozen om de gebruiker hier verantwoordelijk voor te maken, de gebruiker besluit of een shape ge"interesseerd moet zijn in events en voegt hier een (unieke) naam aan toe, als het event dan gevuurd wordt, kan de gebruiker patternmatchen op zijn eigen uniek gekozen naam, en er worden nooit meer events over de lijn verstuurd dan de gebruiker om gevraagd heeft.

Wederom een kleine illustratie, hier wordt een event toegevoegd aan ``Mickey Mouse''

\begin{lstlisting}[style=densecode, language=Haskell]
Event defaults{eventId="mickey", mouseClick = True} $ Fill black $ Translate 100 100 $ Rotate 90 $ Container 200 200 [
            Circle (70, 130) 20,
            Circle (100, 100) 50,
            Circle (130, 130) 20
        ]
\end{lstlisting}

En later in de handler kan dan een specifieke patternmatch toevoegen voor mouseclicks op ons ``Mickey Mouse'' element.
\begin{lstlisting}[style=densecode, language=Haskell]
handler :: State -> Event -> Output
(..)
handler state (MouseClick (x,y) "mickey") = -- Do something useful
\end{lstlisting}

\subsubsection{Defaults}
Een belangrijke discussie was dat de gebruiker niet meer data moet geven dan strict noodzakelijk. Stel dat een gebruiker een MouseClick event wil toevoegen aan een rechthoek, dan moet hij niet expliciet aangeven dat hij geen MouseDrag event wil. Een na"ive oplossing zou een datastructuur definieren in haskell waar de gebruiker elke mogelijkheid expliciet van waarde moet voorzien.

De oplossing is een \inlinecode{Default} typeklasse, een Event heeft een record met velden voor het ID en een aantal booleans voor of hij geinteresseerd is in Events, dit record derived \inlinecode{Defaults} en die typeklasse heeft een functie \inlinecode{defaults}. Deze functie geeft een standaard record terug die leeg is, het ID is leeg en de shape is (met dat record) niet geinteresseerd in events, de gebruiker kan dan die defaults bewerken om de shape een ID te geven en geinteresseerd te laten zijn in events. Een voorbeeld hiervan is hierboven al gegeven, het record gegeven door de \inlinecode{defaults} record is bewerkt en het eventId is "mickey" geworden, verder is de vorm nu geinteresseerd in muiskliks.

Naast dat een gebruiker geen overbodige waarden moet opgeven als hij wel ge"interesseerd is in events, hoeft hij ook geen overbodige Events te defini"eren. Er is een tijd sprake geweest dat Events op een Shape zou werken, zo zou de rechthoek een \inlinecode{Maybe Event} hebben. Doordat er besloten is dat Event een node is in de grafische boom hoeft de gebruiker geen onnodige Nothings aan te geven als een shape niet geinteresseerd is in events, hij voegt gewoon geen Event nodes toe.

\todo{Ontwerpkeuze: Hulpfuncties zoals shape}
\todo{Ontwerpkeuze: Toelichten acties}
%\todo{Ontwerpkeuze: Toelichten van de keuze voor Fullwindow Zie https://drive.google.com/#folders/0B97Qa5VgdaDNWjBiOGFEa3JMZHc}
\todo{Toelichten waarom we blocking actions hebben}
\todo{Ontwerpkeuze toelichten: Super key wordt niet als modifier gezien}
