\subsection{Haskell Interface} \label{subsec:grafische_bibliotheek} \todo{Titel kiezen die dezelfde lading dekt, maar minder engels is}
\todo{Deze subsection moet denk ik voor de 'problemen' subsection}

Onder \fullref{subsec:module} is toegelicht hoe de Canvas.hs-module is opgebouwd en hoe deze gebruikt kan worden. Een uitgebreide toelichting over het gebruik van Canvas.hs is te vinden in \fullref{sec:gebruikershandleiding}. Hieronder zullen enkele belangrijke ontwerpkeuzes voor de module worden toegelicht. Deze keuzes hebben grote invloed op de wijze waarop de module gebruikt moet worden. 

Hieronder zal o.a. worden toegelicht hoe tot de keuze voor de verschillende typen grafische elementen is gekomen, hoe gebeurtenissen aan deze elementen worden gekoppeld en hoe de acties die de gebruiker kan uitvoeren zijn opgebouwd.

\subsubsection{Grafische elementen}
De te tekenen grafische elementen zijn voor de gebruiker het belangrijkste onderdeel van Canvas.hs, er is daarom goed nagedacht over hoe de te tekenen grafische elementen worden gerepresenteerd. 

Grafische elementen worden in Canvas.hs gerepresenteerd door het \inlinecode{Shape}type. Dit type representeert alle mogelijk te tekenen grafische elementen en alle mutaties die daarop mogelijk zijn. Hier is al het e.e.a. over toegelicht onder \fullref{par:globaal_shapes}.

\paragraph{Mutaties}
Door deze representatie ontstaat een boom van shapes (\autoref{dia:grafische_boom}) waarin er shapes zijn die mutaties uitvoeren op andere shapes (zoals bijvoorbeeld \inlinecode{Rotate}) en primitieve shapes (zoals bijvoorbeeld \inlinecode{Rect} of \inlinecode{Circle}). Die mutaties die op shapes kunnen worden uitgevoerd worden dus zelf gerepresenteerd door een shape.

Een alternatief hiervoor is het uitvoeren van mutaties m.b.v. functies. Er zou dan bijvoorbeeld een functie \inlinecode{rotate :: Int -> Shape -> Shape} bestaan die een shape aanpast zodat deze geroteerd is. shapes zouden dan gerepresenteerd worden door een record-type waarin de functie aanpassingen maakt. 

De huidige oplossing had echter de voorkeur aangezien deze, in tegenstelling tot de oplossing m.b.v. functies, niet destructief is. Het is mogelijk om de mutaties weer uit de grafische boom te verwijderen en ze op deze manier ongedaan te maken. Daarnaast zou het gebruik van records voor de shapes voor problemen kunnen zorgen doordat de labels van velden in records in Haskell worden omgezet in functies. Hierdoor kan de gebruiker geen functies meer defini\"eren die de labels van record velden delen.

\paragraph{Positionering}
Voor het positioneren van grafische elementen op het canvas zijn vele mogelijkheden. In canvas.hs hebben we ervoor gekozen dat elk element relatief aan de bovenliggende \inlinecode{Container} wordt gepositioneerd. De bovenstaande \inlinecode{Container} wordt dan weer relatief aan het canvas gepositioneerd. 

Door deze manier van positioneren is het eenvoudig mogelijk om herbruikbare elementen, zoals knoppen e.d., te creeëren. Een functie levert een \inlinecode{Container} op die de knap bevat. Alle elementen van de knop (de text, de vorm van de knop zelf, etc.) zijn relatief aan die Container gepositioneerd. Door de Container vervolgens te positioneren worden alle elementen van de knop met deze container mee verplaatst. 

De keuze voor mutaties als shapes en relatieve positionering wordt hieronder geïllustreerd met een ``Mickey Mouse''-vorm die gedraaid en gekleurd is. De cirkels worden relatief aan de container gepositioneerd, vervolgens wordt de container zelf 100 pixels in de x en y richting verschoven m.b.v. de \inlinecode{Translate-Shape}. 

\begin{lstlisting}[style=densecode, language=Haskell]
Fill black $ Translate 100 100 $ Rotate 90 $ Container 200 200 [
            Circle (70, 130) 20,
            Circle (100, 100) 50,
            Circle (130, 130) 20
        ]
\end{lstlisting}


\subsubsection{Defaults}
Bij de \inlinecode{Text-} en \inlinecode{Event-Shape} wordt gebruik gemaakt van een record om opties mee te geven. In het geval van Text om bijvoorbeeld aan te geven of text dik- of schuingedruk moet worden en in het geval van Events om aan te geven in wat voor type Events interesse is. 

Een belangrijke overweging hierin was dat het voor de gebruiker mogelijk moet zijn om aan te geven dat er interesse is in bijvoorbeeld een mouseClick zonder expliciet aan te moeten geven dat er geen interesse is in bijvoorbeeld een mouseDrag. Met alleen records zou dit wel nodig zijn, aangezien daarbij van elk veld expliciet moet worden aangegeven welke waarde het heeft.

Dit probleem is opgelost met een \inlinecode{Defaults}-typeklasse. Deze definieert één enkele functie (\inlinecode{defaults :: a}) die een default waarde voor het gegeven type dient op te leveren. De gebruiker kan dan m.b.v. deze functie eenvoudig alleen de velden aanpassen waarin hij geïnteresseerd is. In het geval van Events zal de defaultsfunctie een record opleveren waarin voor elk type event stgaat de shape er niet in geïnteresserd is. 

In \autoref{mickey_event} wordt dat geïllustreerd. We breiden onze eerder gebruikte Mickey-vorm nu uit met een interesse in Events. met behulp van de defaultsfunctie krijgen we een record waarin voor elk event staat aangegeven dat er geen interesse in is. Vervolgens passen we dit record aan en geven we aan dat er interesse is in muiskliks.

\subsubsection{ID's}
Om op een praktische manier gebruik te kunnen maken van events worden deze aan shapes gekoppeld. Events die daadwerkelijk op een shape gebeuren (zoals muiklikken) kunnen dan ook identificeren op welke shape dat was. Hiertoe moeten shapes die geïnteresserd zijn in events geïdentificeerd kunnen worden. In Canvas.hs is besloten om de gebruiker, bij het aangeven van interesse in een event, een identifier mee te laten geven voor de shape. Hierdoor is het voor de gebruiker eenvoudig te zien op welke shape het event plaatsvond.

In \autoref{mickey_event} wordt dit geïllustreerd. Aan de eerder gedefiniëerde Mickey-vorm wordt interesse in een Event toegevoegd. De events die plaatsvinden op deze vorm zullen geïdentificeerd worden met de identifier "mickey".

\begin{lstlisting}[style=densecode, language=Haskell, caption=Mickey met interesse in een Event, label=mickey_event]
Event defaults{eventId="mickey", mouseClick=True} $ Fill black $ Translate 100 100 $ Rotate 90 $ Container 200 200 [
            Circle (70, 130) 20,
            Circle (100, 100) 50,
            Circle (130, 130) 20
        ]
\end{lstlisting}

Later in de handler zal de gebruiker bij events die op de Mickey plaatsvinden deze identifier meekrijgen en hier bijvoorbeeld op kunnen patternmatchen, zoals in onderstaande code geïllustreerd.

\begin{lstlisting}[style=densecode, language=Haskell]
handler :: State -> Event -> Output
(..)
handler state (MouseClick (x,y) "mickey") = -- Do something useful
\end{lstlisting}


\subsection{Protocol}
Uiteindelijk is ervoor gekozen om het protocol gelijkend aan Kinetic op te bouwen, zo zijn de meeste JSON berichten die gestuurd worden door de Canvas.Hs module een op een te teken op het canvas. Wel zijn er hier en daar kleine verschillen, JSON-keys die net anders zijn, of er zijn andere keys gebruikt om hetzelfde te modelleren (Een goed voorbeeld hiervan is de kleuren, kleuren worden opgestuurd als object met r, g , b en a waarden, maar Kinetic verwacht een string met een kleur zoals hij geaccepteerd wordt door een webbrowser. De manier hoe Kinetic omgaat met een kleur is een implementatiedetail dat niet thuis hoort in een protocol).
\todo{Niet zo veel tussen haakjes zetten}
\todo{dit aanpassen, ook stukje JSON toevoegen}
