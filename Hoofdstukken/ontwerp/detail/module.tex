\subsection{Module}
De module is de Haskell bibliotheek die de programmeur gebruikt om de grafische interface in de client te bedienen. Naar de programmeur is de gebruiksvriendelijkheid van de bibliotheek een van de belangrijkste overwegingen voor het ontwerp. De module bestaat uit een aantal onderdelen: de server die de statische bestanden serveert, de websocket server die de verbinding met de client onderhoudt, en de laag die de input en output verwerkt. \autoref{fig:architecture_module} geeft de architectuur weer van de module.

\begin{figure}
\begin{center}
\includegraphics[keepaspectratio,width=\textwidth]{./images/module_architecture.pdf}
\caption{Architectuur van de module}
\label{fig:architecture_module}
\end{center}
\end{figure}

\paragraph{Servers}
Canvas.hs draait een simpele server op port 80 die statische bestanden kan serveren. Waaronder de index pagina, de javascript bestanden en eventueel plaatjes. Op port 8080 draait een websocket server die de verbinding met de client onderhoudt.


\paragraph{Server in de module}
De server draait in het proces dat gestart wordt vanuit de Haskell-code van de programmeur. De main van de programmeur start (indirect) de server. Dit is eenvoudiger dan het draaien van de server in een apart proces. Er hoeft namelijk niet tussen verschillende Haskell-processen gecommuniceerd te worden. Dit scheelt het schrijven van nog een interface tussen het server- en het module proces. Nadeel is wel dat het voortdurend opnieuw starten en afsluiten van de server leidt tot vertraging in het opstarten van het programma van de programmeur. Dit is vervelend als de programmeur regelmatig kleine wijzigingen maakt en dan de code opnieuw moet starten. Echter lijkt de overhead van het opnieuw starten van de server minimaal. Het is verder praktisch dat er geen rekening gehouden hoeft te worden met de state van de server bij het opstarten van het programma.

\paragraph{Gebruik} Wanneer de programmeur gebruik wil maken van de Canvas.hs moet hij gebruik maken van de installEventHandler functie. Bij het aanroepen van deze functie moet de programmeur een eventhandler meegeven die alle events vanuit de interface afhandelt. Om het gebruik van Canvas.hs zo makkelijk mogelijk te houden zal bij het aanroepen van installEventHandler automatisch de statische server en de websocket server gestart worden, en daarna automatisch de browserpagina geopend worden. \autoref{fig:startup_procedure} geeft de opstartprocedure weer.

\begin{figure}
\begin{center}
\includegraphics[keepaspectratio,width=\textwidth]{./images/module_startup_procedure_interaction.pdf}
\caption{De opstartprocedure en initiele interactiesequentie}
\label{fig:startup_procedure}
\end{center}
\end{figure}
\todo{Is het nou event handler of eventhandler?}
\paragraph{Input/output}
De module handelt input en output af door events naar de eventhandler van de programmeur te sturen. Bijvoorbeeld: wanneer een gebruiker op een rondje klikt zal het programma de eventhandler aanroepen met de ID van dat rondje en de locatie van de muisklik. De eventhandler van de programmeur kan dan nieuwe output genereren op basis van dit event. Zoals een nieuw menu weergeven of het uitvoeren van een actie zoals het opvragen van een bestand van de gebruiker.In \autoref{fig:startup_procedure} is deze interactie weergegeven.

De programmeur zal in zijn eventhandler bij ieder event de huidige state en de huidige event meekrijgen. Het type van de eventhandler is \inlinecode{userState -> Event -> (userState, Output)}, waarin de programmeur elk type aan userState kan geven. Door middel van pattern matching kan de programmeur makkelijk een bepaald event opvangen. Bijvoorbeeld: een muisklikevent wordt opgevangen door: \inlinecode{handler state (MouseClick (x,y) "id")}. De returnwaarde van de eventhandler is een tuple van de nieuwe state en de output. Output is een tuple van \inlinecode{(Maybe Shape, [Action])}. De eventhandler kan meerdere acties tegelijk uitvoeren en/of een grafische output leveren. De ondersteunde events en outputtypes worden verder toegelicht in \autoref{subsec:grafische_bibliotheek}.

\paragraph{Timers}
\todo{Als je ze in JS bijhoudt dan in Haskell verschillende threads? groot voordeel van wat?}
Canvas.Hs ondersteunt timers die ervoor zorgen dat met een bepaald interval een event naar de eventhandler wordt verstuurd. Hiermee kunnen bijvoorbeeld animaties worden toegevoegd aan de interface. Zoals het animeren van een bal of het animeren van een hele game. \todo{onduidelijk wat wordt hier mee bedoeld}Deze timers worden bijgehouden in de module. Een alternatief is om de timers aan de client over te laten. Dit heeft als voordeel dat het makkelijker is om timers bij te houden in JavaScript dan in Haskell. In Haskell moeten de timers per thread bijgehouden worden, in JavaScript gaat dit automatisch. Het voornaamste voordeel om het in de module te plaatsen is dat er geen extra acties over de WebSocketconnectie verzonden worden en dat een implementatie direct in Haskell meer precisie geeft voor de timer.

\paragraph{Unsafe I/O}
In Server.hs wordt gebruik gemaakt van unsafePreformIO voor het starten van child processen (een MVar die threads bijhoudt) en om een verbinding met een client bij te houden (een IORef die de connections naar de clients bevat). Hoewel het in dit geval volkomen veilig is, zijn er bezwaren tegen het gebruik van unsafePerformIO\cite{Haskell.org2008}. Dit is namelijk niet de netste oplossing en kan meestal voorkomen worden. Het is netter om een Server Monad te gebruiken die een State implementeert die deze zaken bijhoudt. Echter is het implementeren daarvan tijdsintensief, waardoor voor deze oplossing is gekozen.