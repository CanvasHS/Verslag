\subsection{Externe libraries}

\subsubsection{Webserver}
Om de statische files van onze library te serveren hebben we een HTTP-server nodig, we hebben hier gekozen voor ``warp''. Warp biedt een lichtgewicht webserver die goed gedocumenteerd en ondersteund is. Andere opties waren ``happstack'', ``hyena'' en ``snap server"". Dit zijn eigenlijk volledige webframeworks, wij hoefden slechts statische files te serveren. Voor de eenvoud en onderhoudbaarheid was ``warp'' de beste keuze.

\subsubsection{Websocketserver}
De websocketserver is degene die connecties tussen de Haskell en Javascript onderhoudt, we hebben hier gekozen voor de ``websockets'' library. Er had gekozen kunnen worden om hieromheen de ``wai'' wrapper te gebruiken, maar omdat we weinig gebruik maken van andere functionaliteit van ``wai'' hebben we het bij de normale library gehouden.

Binnen de websockets zijn er verschillende protocollen gedefineerd, welke in verschillende browsers geimplementeerd zijn. De meest recente versie van het websockets protocol poogt een standaard te worden (RFC6455) en de websockets library heeft daar tijdens ons ontwerpproject support voor gekregen. De meeste recente browsers hebben RFC-6455 geimplementeerd, en de verwachting is dat deze versie van het protocol lange tijd ondersteund wordt.

\subsubsection{JSON}
Binnen ons protocol gebruiken we JSON. In eerste instantie wilden we hiervoor een eigen parser schrijven, we waren namelijk sceptisch over het gebruik van een library omdat het parsen van JSON niet moeilijk lijkt omdat de libraries ingewikkeld leken. Uiteindelijk hebben we toch een library genomen, libraries vertrouwde stukken code zijn waarvan al geverifieerd is dat ze werken, daartoe bespaart het ons veel tijd en hebben we een solide basis van onze code.

Er zijn voor haskell twee bekende JSON libraries, Text.JSON en Aeson. In eerste instantie hebben we gekeken naar Text.JSON maar al snel bleek dat deze library slecht gedocumenteerd is. Daarna hebben we naar Aeson gekeken, Aeson is beter gedocumenteerd en biedt eenzelfde workflow.
Binnen Aeson is er gekozen om Template Haskell functies te gebruiken, dit is een GHC extensie die een soort van metaprogramming toevoegd aan Haskell. Template Haskell is gebruikt om lege keys uit de \todo{robert: gaan jullie hier nog meer over vertellen?}JSON te verwijderen en een record probleem van Haskell te omzeilen.

\subsubsection{Tests}
Als testingframework hebben we voor Hspec gekozen. Hspec integreert goed met andere testframeworks zoals QuickCheck en HUnit maar daarbovenop voegt het verhalende syntax toe aan de testcases. Ook zoekt Hspec automatisch naar testcases, en paralleliseerd het testcode.

Binnen Hspec maken we ook gebruik van QuickCheck, deze library kan arbitraire testcases testen. Hiervoor dient de input gedefineerd te worden en dan zal QuickCheck een groot aantal testcases loslaten op de code. Vaak gebruiken we eerst een voorgedefineerde testcase (van HSpec zelf, wat weer een wrapper om HUnit is), en daarnaast een arbitrair aantal extra testcases gegenereerd door QuickCheck. Zo weten we dat het geen toeval was dat onze tests checkte en kunnen we zonder al te veel moeite veel gevallen proberen.
